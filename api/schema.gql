# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateBookableItem {
  _avg: BookableItemAvgAggregate
  _count: BookableItemCountAggregate
  _max: BookableItemMaxAggregate
  _min: BookableItemMinAggregate
  _sum: BookableItemSumAggregate
}

type AggregateBookableItemTypes {
  _avg: BookableItemTypesAvgAggregate
  _count: BookableItemTypesCountAggregate
  _max: BookableItemTypesMaxAggregate
  _min: BookableItemTypesMinAggregate
  _sum: BookableItemTypesSumAggregate
}

type AggregateBuilding {
  _avg: BuildingAvgAggregate
  _count: BuildingCountAggregate
  _max: BuildingMaxAggregate
  _min: BuildingMinAggregate
  _sum: BuildingSumAggregate
}

type AggregateBuildingManager {
  _avg: BuildingManagerAvgAggregate
  _count: BuildingManagerCountAggregate
  _max: BuildingManagerMaxAggregate
  _min: BuildingManagerMinAggregate
  _sum: BuildingManagerSumAggregate
}

type AggregateOffice {
  _avg: OfficeAvgAggregate
  _count: OfficeCountAggregate
  _max: OfficeMaxAggregate
  _min: OfficeMinAggregate
  _sum: OfficeSumAggregate
}

type AggregateOfficeManager {
  _avg: OfficeManagerAvgAggregate
  _count: OfficeManagerCountAggregate
  _max: OfficeManagerMaxAggregate
  _min: OfficeManagerMinAggregate
  _sum: OfficeManagerSumAggregate
}

type AggregateReservation {
  _avg: ReservationAvgAggregate
  _count: ReservationCountAggregate
  _max: ReservationMaxAggregate
  _min: ReservationMinAggregate
  _sum: ReservationSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type BookableItem {
  available: Boolean
  createdAt: DateTime
  id: Int!
  name: String!
  office: Office!
  officeExclusive: Boolean!
  officeId: Int!
  reservations(cursor: ReservationWhereUniqueInput, distinct: [ReservationScalarFieldEnum!], orderBy: [ReservationOrderByInput!], skip: Int, take: Int, where: ReservationWhereInput): [Reservation!]!
  type: BookableItemTypes!
  typeId: Int!
  updatedAt: DateTime
}

type BookableItemAvgAggregate {
  id: Float
  officeId: Float
  typeId: Float
}

type BookableItemCountAggregate {
  _all: Int!
  available: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  officeExclusive: Int!
  officeId: Int!
  typeId: Int!
  updatedAt: Int!
}

input BookableItemCreateInput {
  available: Boolean
  createdAt: DateTime
  name: String!
  office: OfficeCreateNestedOneWithoutBookableItemsInput!
  officeExclusive: Boolean
  reservations: ReservationCreateNestedManyWithoutBookedItemInput
  type: BookableItemTypesCreateNestedOneWithoutBookableItemsInput!
  updatedAt: DateTime
}

input BookableItemCreateManyInput {
  available: Boolean
  createdAt: DateTime
  id: Int
  name: String!
  officeExclusive: Boolean
  officeId: Int!
  typeId: Int!
  updatedAt: DateTime
}

input BookableItemCreateManyOfficeInput {
  available: Boolean
  createdAt: DateTime
  id: Int
  name: String!
  officeExclusive: Boolean
  typeId: Int!
  updatedAt: DateTime
}

input BookableItemCreateManyOfficeInputEnvelope {
  data: [BookableItemCreateManyOfficeInput!]!
  skipDuplicates: Boolean
}

input BookableItemCreateManyTypeInput {
  available: Boolean
  createdAt: DateTime
  id: Int
  name: String!
  officeExclusive: Boolean
  officeId: Int!
  updatedAt: DateTime
}

input BookableItemCreateManyTypeInputEnvelope {
  data: [BookableItemCreateManyTypeInput!]!
  skipDuplicates: Boolean
}

input BookableItemCreateNestedManyWithoutOfficeInput {
  connect: [BookableItemWhereUniqueInput!]
  connectOrCreate: [BookableItemCreateOrConnectWithoutOfficeInput!]
  create: [BookableItemCreateWithoutOfficeInput!]
  createMany: BookableItemCreateManyOfficeInputEnvelope
}

input BookableItemCreateNestedManyWithoutTypeInput {
  connect: [BookableItemWhereUniqueInput!]
  connectOrCreate: [BookableItemCreateOrConnectWithoutTypeInput!]
  create: [BookableItemCreateWithoutTypeInput!]
  createMany: BookableItemCreateManyTypeInputEnvelope
}

input BookableItemCreateNestedOneWithoutReservationsInput {
  connect: BookableItemWhereUniqueInput
  connectOrCreate: BookableItemCreateOrConnectWithoutReservationsInput
  create: BookableItemCreateWithoutReservationsInput
}

input BookableItemCreateOrConnectWithoutOfficeInput {
  create: BookableItemCreateWithoutOfficeInput!
  where: BookableItemWhereUniqueInput!
}

input BookableItemCreateOrConnectWithoutReservationsInput {
  create: BookableItemCreateWithoutReservationsInput!
  where: BookableItemWhereUniqueInput!
}

input BookableItemCreateOrConnectWithoutTypeInput {
  create: BookableItemCreateWithoutTypeInput!
  where: BookableItemWhereUniqueInput!
}

input BookableItemCreateWithoutOfficeInput {
  available: Boolean
  createdAt: DateTime
  name: String!
  officeExclusive: Boolean
  reservations: ReservationCreateNestedManyWithoutBookedItemInput
  type: BookableItemTypesCreateNestedOneWithoutBookableItemsInput!
  updatedAt: DateTime
}

input BookableItemCreateWithoutReservationsInput {
  available: Boolean
  createdAt: DateTime
  name: String!
  office: OfficeCreateNestedOneWithoutBookableItemsInput!
  officeExclusive: Boolean
  type: BookableItemTypesCreateNestedOneWithoutBookableItemsInput!
  updatedAt: DateTime
}

input BookableItemCreateWithoutTypeInput {
  available: Boolean
  createdAt: DateTime
  name: String!
  office: OfficeCreateNestedOneWithoutBookableItemsInput!
  officeExclusive: Boolean
  reservations: ReservationCreateNestedManyWithoutBookedItemInput
  updatedAt: DateTime
}

type BookableItemGroupBy {
  _avg: BookableItemAvgAggregate
  _count: BookableItemCountAggregate
  _max: BookableItemMaxAggregate
  _min: BookableItemMinAggregate
  _sum: BookableItemSumAggregate
  available: Boolean
  createdAt: DateTime
  id: Int!
  name: String!
  officeExclusive: Boolean!
  officeId: Int!
  typeId: Int!
  updatedAt: DateTime
}

input BookableItemListRelationFilter {
  every: BookableItemWhereInput
  none: BookableItemWhereInput
  some: BookableItemWhereInput
}

type BookableItemMaxAggregate {
  available: Boolean
  createdAt: DateTime
  id: Int
  name: String
  officeExclusive: Boolean
  officeId: Int
  typeId: Int
  updatedAt: DateTime
}

type BookableItemMinAggregate {
  available: Boolean
  createdAt: DateTime
  id: Int
  name: String
  officeExclusive: Boolean
  officeId: Int
  typeId: Int
  updatedAt: DateTime
}

input BookableItemOrderByInput {
  available: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  officeExclusive: SortOrder
  officeId: SortOrder
  typeId: SortOrder
  updatedAt: SortOrder
}

input BookableItemRelationFilter {
  is: BookableItemWhereInput
  isNot: BookableItemWhereInput
}

enum BookableItemScalarFieldEnum {
  available
  createdAt
  id
  name
  officeExclusive
  officeId
  typeId
  updatedAt
}

input BookableItemScalarWhereInput {
  AND: [BookableItemScalarWhereInput!]
  NOT: [BookableItemScalarWhereInput!]
  OR: [BookableItemScalarWhereInput!]
  available: BoolNullableFilter
  createdAt: DateTimeNullableFilter
  id: IntFilter
  name: StringFilter
  officeExclusive: BoolFilter
  officeId: IntFilter
  typeId: IntFilter
  updatedAt: DateTimeNullableFilter
}

input BookableItemScalarWhereWithAggregatesInput {
  AND: [BookableItemScalarWhereWithAggregatesInput!]
  NOT: [BookableItemScalarWhereWithAggregatesInput!]
  OR: [BookableItemScalarWhereWithAggregatesInput!]
  available: BoolNullableWithAggregatesFilter
  createdAt: DateTimeNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  officeExclusive: BoolWithAggregatesFilter
  officeId: IntWithAggregatesFilter
  typeId: IntWithAggregatesFilter
  updatedAt: DateTimeNullableWithAggregatesFilter
}

type BookableItemSumAggregate {
  id: Int
  officeId: Int
  typeId: Int
}

type BookableItemTypes {
  bookableItems(cursor: BookableItemWhereUniqueInput, distinct: [BookableItemScalarFieldEnum!], orderBy: [BookableItemOrderByInput!], skip: Int, take: Int, where: BookableItemWhereInput): [BookableItem!]!
  createdAt: DateTime
  id: Int!
  name: String!
  updatedAt: DateTime
}

type BookableItemTypesAvgAggregate {
  id: Float
}

type BookableItemTypesCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input BookableItemTypesCreateInput {
  bookableItems: BookableItemCreateNestedManyWithoutTypeInput
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

input BookableItemTypesCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input BookableItemTypesCreateNestedOneWithoutBookableItemsInput {
  connect: BookableItemTypesWhereUniqueInput
  connectOrCreate: BookableItemTypesCreateOrConnectWithoutBookableItemsInput
  create: BookableItemTypesCreateWithoutBookableItemsInput
}

input BookableItemTypesCreateOrConnectWithoutBookableItemsInput {
  create: BookableItemTypesCreateWithoutBookableItemsInput!
  where: BookableItemTypesWhereUniqueInput!
}

input BookableItemTypesCreateWithoutBookableItemsInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

type BookableItemTypesGroupBy {
  _avg: BookableItemTypesAvgAggregate
  _count: BookableItemTypesCountAggregate
  _max: BookableItemTypesMaxAggregate
  _min: BookableItemTypesMinAggregate
  _sum: BookableItemTypesSumAggregate
  createdAt: DateTime
  id: Int!
  name: String!
  updatedAt: DateTime
}

type BookableItemTypesMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

type BookableItemTypesMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input BookableItemTypesOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input BookableItemTypesRelationFilter {
  is: BookableItemTypesWhereInput
  isNot: BookableItemTypesWhereInput
}

enum BookableItemTypesScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input BookableItemTypesScalarWhereWithAggregatesInput {
  AND: [BookableItemTypesScalarWhereWithAggregatesInput!]
  NOT: [BookableItemTypesScalarWhereWithAggregatesInput!]
  OR: [BookableItemTypesScalarWhereWithAggregatesInput!]
  createdAt: DateTimeNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeNullableWithAggregatesFilter
}

type BookableItemTypesSumAggregate {
  id: Int
}

input BookableItemTypesUpdateInput {
  bookableItems: BookableItemUpdateManyWithoutTypeInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BookableItemTypesUpdateManyMutationInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BookableItemTypesUpdateOneRequiredWithoutBookableItemsInput {
  connect: BookableItemTypesWhereUniqueInput
  connectOrCreate: BookableItemTypesCreateOrConnectWithoutBookableItemsInput
  create: BookableItemTypesCreateWithoutBookableItemsInput
  update: BookableItemTypesUpdateWithoutBookableItemsInput
  upsert: BookableItemTypesUpsertWithoutBookableItemsInput
}

input BookableItemTypesUpdateWithoutBookableItemsInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BookableItemTypesUpsertWithoutBookableItemsInput {
  create: BookableItemTypesCreateWithoutBookableItemsInput!
  update: BookableItemTypesUpdateWithoutBookableItemsInput!
}

input BookableItemTypesWhereInput {
  AND: [BookableItemTypesWhereInput!]
  NOT: [BookableItemTypesWhereInput!]
  OR: [BookableItemTypesWhereInput!]
  bookableItems: BookableItemListRelationFilter
  createdAt: DateTimeNullableFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeNullableFilter
}

input BookableItemTypesWhereUniqueInput {
  id: Int
}

input BookableItemUpdateInput {
  available: NullableBoolFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  office: OfficeUpdateOneRequiredWithoutBookableItemsInput
  officeExclusive: BoolFieldUpdateOperationsInput
  reservations: ReservationUpdateManyWithoutBookedItemInput
  type: BookableItemTypesUpdateOneRequiredWithoutBookableItemsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BookableItemUpdateManyMutationInput {
  available: NullableBoolFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  officeExclusive: BoolFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BookableItemUpdateManyWithWhereWithoutOfficeInput {
  data: BookableItemUpdateManyMutationInput!
  where: BookableItemScalarWhereInput!
}

input BookableItemUpdateManyWithWhereWithoutTypeInput {
  data: BookableItemUpdateManyMutationInput!
  where: BookableItemScalarWhereInput!
}

input BookableItemUpdateManyWithoutOfficeInput {
  connect: [BookableItemWhereUniqueInput!]
  connectOrCreate: [BookableItemCreateOrConnectWithoutOfficeInput!]
  create: [BookableItemCreateWithoutOfficeInput!]
  createMany: BookableItemCreateManyOfficeInputEnvelope
  delete: [BookableItemWhereUniqueInput!]
  deleteMany: [BookableItemScalarWhereInput!]
  disconnect: [BookableItemWhereUniqueInput!]
  set: [BookableItemWhereUniqueInput!]
  update: [BookableItemUpdateWithWhereUniqueWithoutOfficeInput!]
  updateMany: [BookableItemUpdateManyWithWhereWithoutOfficeInput!]
  upsert: [BookableItemUpsertWithWhereUniqueWithoutOfficeInput!]
}

input BookableItemUpdateManyWithoutTypeInput {
  connect: [BookableItemWhereUniqueInput!]
  connectOrCreate: [BookableItemCreateOrConnectWithoutTypeInput!]
  create: [BookableItemCreateWithoutTypeInput!]
  createMany: BookableItemCreateManyTypeInputEnvelope
  delete: [BookableItemWhereUniqueInput!]
  deleteMany: [BookableItemScalarWhereInput!]
  disconnect: [BookableItemWhereUniqueInput!]
  set: [BookableItemWhereUniqueInput!]
  update: [BookableItemUpdateWithWhereUniqueWithoutTypeInput!]
  updateMany: [BookableItemUpdateManyWithWhereWithoutTypeInput!]
  upsert: [BookableItemUpsertWithWhereUniqueWithoutTypeInput!]
}

input BookableItemUpdateOneRequiredWithoutReservationsInput {
  connect: BookableItemWhereUniqueInput
  connectOrCreate: BookableItemCreateOrConnectWithoutReservationsInput
  create: BookableItemCreateWithoutReservationsInput
  update: BookableItemUpdateWithoutReservationsInput
  upsert: BookableItemUpsertWithoutReservationsInput
}

input BookableItemUpdateWithWhereUniqueWithoutOfficeInput {
  data: BookableItemUpdateWithoutOfficeInput!
  where: BookableItemWhereUniqueInput!
}

input BookableItemUpdateWithWhereUniqueWithoutTypeInput {
  data: BookableItemUpdateWithoutTypeInput!
  where: BookableItemWhereUniqueInput!
}

input BookableItemUpdateWithoutOfficeInput {
  available: NullableBoolFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  officeExclusive: BoolFieldUpdateOperationsInput
  reservations: ReservationUpdateManyWithoutBookedItemInput
  type: BookableItemTypesUpdateOneRequiredWithoutBookableItemsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BookableItemUpdateWithoutReservationsInput {
  available: NullableBoolFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  office: OfficeUpdateOneRequiredWithoutBookableItemsInput
  officeExclusive: BoolFieldUpdateOperationsInput
  type: BookableItemTypesUpdateOneRequiredWithoutBookableItemsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BookableItemUpdateWithoutTypeInput {
  available: NullableBoolFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  office: OfficeUpdateOneRequiredWithoutBookableItemsInput
  officeExclusive: BoolFieldUpdateOperationsInput
  reservations: ReservationUpdateManyWithoutBookedItemInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BookableItemUpsertWithWhereUniqueWithoutOfficeInput {
  create: BookableItemCreateWithoutOfficeInput!
  update: BookableItemUpdateWithoutOfficeInput!
  where: BookableItemWhereUniqueInput!
}

input BookableItemUpsertWithWhereUniqueWithoutTypeInput {
  create: BookableItemCreateWithoutTypeInput!
  update: BookableItemUpdateWithoutTypeInput!
  where: BookableItemWhereUniqueInput!
}

input BookableItemUpsertWithoutReservationsInput {
  create: BookableItemCreateWithoutReservationsInput!
  update: BookableItemUpdateWithoutReservationsInput!
}

input BookableItemWhereInput {
  AND: [BookableItemWhereInput!]
  NOT: [BookableItemWhereInput!]
  OR: [BookableItemWhereInput!]
  available: BoolNullableFilter
  createdAt: DateTimeNullableFilter
  id: IntFilter
  name: StringFilter
  office: OfficeRelationFilter
  officeExclusive: BoolFilter
  officeId: IntFilter
  reservations: ReservationListRelationFilter
  type: BookableItemTypesRelationFilter
  typeId: IntFilter
  updatedAt: DateTimeNullableFilter
}

input BookableItemWhereUniqueInput {
  id: Int
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input BoolNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBoolNullableFilter
  _min: NestedBoolNullableFilter
  equals: Boolean
  not: NestedBoolNullableWithAggregatesFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type Building {
  buildingManagers(cursor: BuildingManagerWhereUniqueInput, distinct: [BuildingManagerScalarFieldEnum!], orderBy: [BuildingManagerOrderByInput!], skip: Int, take: Int, where: BuildingManagerWhereInput): [BuildingManager!]!
  createdAt: DateTime
  id: Int!
  name: String!
  offices(cursor: OfficeWhereUniqueInput, distinct: [OfficeScalarFieldEnum!], orderBy: [OfficeOrderByInput!], skip: Int, take: Int, where: OfficeWhereInput): [Office!]!
  updatedAt: DateTime
}

type BuildingAvgAggregate {
  id: Float
}

type BuildingCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input BuildingCreateInput {
  buildingManagers: BuildingManagerCreateNestedManyWithoutBuildingInput
  createdAt: DateTime
  name: String!
  offices: OfficeCreateNestedManyWithoutBuildingInput
  updatedAt: DateTime
}

input BuildingCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input BuildingCreateNestedOneWithoutBuildingManagersInput {
  connect: BuildingWhereUniqueInput
  connectOrCreate: BuildingCreateOrConnectWithoutBuildingManagersInput
  create: BuildingCreateWithoutBuildingManagersInput
}

input BuildingCreateNestedOneWithoutOfficesInput {
  connect: BuildingWhereUniqueInput
  connectOrCreate: BuildingCreateOrConnectWithoutOfficesInput
  create: BuildingCreateWithoutOfficesInput
}

input BuildingCreateOrConnectWithoutBuildingManagersInput {
  create: BuildingCreateWithoutBuildingManagersInput!
  where: BuildingWhereUniqueInput!
}

input BuildingCreateOrConnectWithoutOfficesInput {
  create: BuildingCreateWithoutOfficesInput!
  where: BuildingWhereUniqueInput!
}

input BuildingCreateWithoutBuildingManagersInput {
  createdAt: DateTime
  name: String!
  offices: OfficeCreateNestedManyWithoutBuildingInput
  updatedAt: DateTime
}

input BuildingCreateWithoutOfficesInput {
  buildingManagers: BuildingManagerCreateNestedManyWithoutBuildingInput
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

type BuildingGroupBy {
  _avg: BuildingAvgAggregate
  _count: BuildingCountAggregate
  _max: BuildingMaxAggregate
  _min: BuildingMinAggregate
  _sum: BuildingSumAggregate
  createdAt: DateTime
  id: Int!
  name: String!
  updatedAt: DateTime
}

type BuildingManager {
  building: Building!
  buildingId: Int!
  createdAt: DateTime
  id: Int!
  name: String!
  updatedAt: DateTime
}

type BuildingManagerAvgAggregate {
  buildingId: Float
  id: Float
}

type BuildingManagerCountAggregate {
  _all: Int!
  buildingId: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input BuildingManagerCreateInput {
  building: BuildingCreateNestedOneWithoutBuildingManagersInput!
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

input BuildingManagerCreateManyBuildingInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input BuildingManagerCreateManyBuildingInputEnvelope {
  data: [BuildingManagerCreateManyBuildingInput!]!
  skipDuplicates: Boolean
}

input BuildingManagerCreateManyInput {
  buildingId: Int!
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input BuildingManagerCreateNestedManyWithoutBuildingInput {
  connect: [BuildingManagerWhereUniqueInput!]
  connectOrCreate: [BuildingManagerCreateOrConnectWithoutBuildingInput!]
  create: [BuildingManagerCreateWithoutBuildingInput!]
  createMany: BuildingManagerCreateManyBuildingInputEnvelope
}

input BuildingManagerCreateOrConnectWithoutBuildingInput {
  create: BuildingManagerCreateWithoutBuildingInput!
  where: BuildingManagerWhereUniqueInput!
}

input BuildingManagerCreateWithoutBuildingInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

type BuildingManagerGroupBy {
  _avg: BuildingManagerAvgAggregate
  _count: BuildingManagerCountAggregate
  _max: BuildingManagerMaxAggregate
  _min: BuildingManagerMinAggregate
  _sum: BuildingManagerSumAggregate
  buildingId: Int!
  createdAt: DateTime
  id: Int!
  name: String!
  updatedAt: DateTime
}

input BuildingManagerListRelationFilter {
  every: BuildingManagerWhereInput
  none: BuildingManagerWhereInput
  some: BuildingManagerWhereInput
}

type BuildingManagerMaxAggregate {
  buildingId: Int
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

type BuildingManagerMinAggregate {
  buildingId: Int
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input BuildingManagerOrderByInput {
  buildingId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

enum BuildingManagerScalarFieldEnum {
  buildingId
  createdAt
  id
  name
  updatedAt
}

input BuildingManagerScalarWhereInput {
  AND: [BuildingManagerScalarWhereInput!]
  NOT: [BuildingManagerScalarWhereInput!]
  OR: [BuildingManagerScalarWhereInput!]
  buildingId: IntFilter
  createdAt: DateTimeNullableFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeNullableFilter
}

input BuildingManagerScalarWhereWithAggregatesInput {
  AND: [BuildingManagerScalarWhereWithAggregatesInput!]
  NOT: [BuildingManagerScalarWhereWithAggregatesInput!]
  OR: [BuildingManagerScalarWhereWithAggregatesInput!]
  buildingId: IntWithAggregatesFilter
  createdAt: DateTimeNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeNullableWithAggregatesFilter
}

type BuildingManagerSumAggregate {
  buildingId: Int
  id: Int
}

input BuildingManagerUpdateInput {
  building: BuildingUpdateOneRequiredWithoutBuildingManagersInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BuildingManagerUpdateManyMutationInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BuildingManagerUpdateManyWithWhereWithoutBuildingInput {
  data: BuildingManagerUpdateManyMutationInput!
  where: BuildingManagerScalarWhereInput!
}

input BuildingManagerUpdateManyWithoutBuildingInput {
  connect: [BuildingManagerWhereUniqueInput!]
  connectOrCreate: [BuildingManagerCreateOrConnectWithoutBuildingInput!]
  create: [BuildingManagerCreateWithoutBuildingInput!]
  createMany: BuildingManagerCreateManyBuildingInputEnvelope
  delete: [BuildingManagerWhereUniqueInput!]
  deleteMany: [BuildingManagerScalarWhereInput!]
  disconnect: [BuildingManagerWhereUniqueInput!]
  set: [BuildingManagerWhereUniqueInput!]
  update: [BuildingManagerUpdateWithWhereUniqueWithoutBuildingInput!]
  updateMany: [BuildingManagerUpdateManyWithWhereWithoutBuildingInput!]
  upsert: [BuildingManagerUpsertWithWhereUniqueWithoutBuildingInput!]
}

input BuildingManagerUpdateWithWhereUniqueWithoutBuildingInput {
  data: BuildingManagerUpdateWithoutBuildingInput!
  where: BuildingManagerWhereUniqueInput!
}

input BuildingManagerUpdateWithoutBuildingInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BuildingManagerUpsertWithWhereUniqueWithoutBuildingInput {
  create: BuildingManagerCreateWithoutBuildingInput!
  update: BuildingManagerUpdateWithoutBuildingInput!
  where: BuildingManagerWhereUniqueInput!
}

input BuildingManagerWhereInput {
  AND: [BuildingManagerWhereInput!]
  NOT: [BuildingManagerWhereInput!]
  OR: [BuildingManagerWhereInput!]
  building: BuildingRelationFilter
  buildingId: IntFilter
  createdAt: DateTimeNullableFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeNullableFilter
}

input BuildingManagerWhereUniqueInput {
  id: Int
}

type BuildingMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

type BuildingMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input BuildingOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input BuildingRelationFilter {
  is: BuildingWhereInput
  isNot: BuildingWhereInput
}

enum BuildingScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input BuildingScalarWhereWithAggregatesInput {
  AND: [BuildingScalarWhereWithAggregatesInput!]
  NOT: [BuildingScalarWhereWithAggregatesInput!]
  OR: [BuildingScalarWhereWithAggregatesInput!]
  createdAt: DateTimeNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeNullableWithAggregatesFilter
}

type BuildingSumAggregate {
  id: Int
}

input BuildingUpdateInput {
  buildingManagers: BuildingManagerUpdateManyWithoutBuildingInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  offices: OfficeUpdateManyWithoutBuildingInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BuildingUpdateManyMutationInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BuildingUpdateOneRequiredWithoutBuildingManagersInput {
  connect: BuildingWhereUniqueInput
  connectOrCreate: BuildingCreateOrConnectWithoutBuildingManagersInput
  create: BuildingCreateWithoutBuildingManagersInput
  update: BuildingUpdateWithoutBuildingManagersInput
  upsert: BuildingUpsertWithoutBuildingManagersInput
}

input BuildingUpdateOneRequiredWithoutOfficesInput {
  connect: BuildingWhereUniqueInput
  connectOrCreate: BuildingCreateOrConnectWithoutOfficesInput
  create: BuildingCreateWithoutOfficesInput
  update: BuildingUpdateWithoutOfficesInput
  upsert: BuildingUpsertWithoutOfficesInput
}

input BuildingUpdateWithoutBuildingManagersInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  offices: OfficeUpdateManyWithoutBuildingInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BuildingUpdateWithoutOfficesInput {
  buildingManagers: BuildingManagerUpdateManyWithoutBuildingInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input BuildingUpsertWithoutBuildingManagersInput {
  create: BuildingCreateWithoutBuildingManagersInput!
  update: BuildingUpdateWithoutBuildingManagersInput!
}

input BuildingUpsertWithoutOfficesInput {
  create: BuildingCreateWithoutOfficesInput!
  update: BuildingUpdateWithoutOfficesInput!
}

input BuildingWhereInput {
  AND: [BuildingWhereInput!]
  NOT: [BuildingWhereInput!]
  OR: [BuildingWhereInput!]
  buildingManagers: BuildingManagerListRelationFilter
  createdAt: DateTimeNullableFilter
  id: IntFilter
  name: StringFilter
  offices: OfficeListRelationFilter
  updatedAt: DateTimeNullableFilter
}

input BuildingWhereUniqueInput {
  id: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createBookableItem(data: BookableItemCreateInput!): BookableItem!
  createBookableItemTypes(data: BookableItemTypesCreateInput!): BookableItemTypes!
  createBuilding(data: BuildingCreateInput!): Building!
  createBuildingManager(data: BuildingManagerCreateInput!): BuildingManager!
  createManyBookableItem(data: [BookableItemCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyBookableItemTypes(data: [BookableItemTypesCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyBuilding(data: [BuildingCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyBuildingManager(data: [BuildingManagerCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyOffice(data: [OfficeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyOfficeManager(data: [OfficeManagerCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyReservation(data: [ReservationCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOffice(data: OfficeCreateInput!): Office!
  createOfficeManager(data: OfficeManagerCreateInput!): OfficeManager!
  createReservation(data: ReservationCreateInput!): Reservation!
  createUser(data: UserCreateInput!): User!
  deleteBookableItem(where: BookableItemWhereUniqueInput!): BookableItem
  deleteBookableItemTypes(where: BookableItemTypesWhereUniqueInput!): BookableItemTypes
  deleteBuilding(where: BuildingWhereUniqueInput!): Building
  deleteBuildingManager(where: BuildingManagerWhereUniqueInput!): BuildingManager
  deleteManyBookableItem(where: BookableItemWhereInput): AffectedRowsOutput!
  deleteManyBookableItemTypes(where: BookableItemTypesWhereInput): AffectedRowsOutput!
  deleteManyBuilding(where: BuildingWhereInput): AffectedRowsOutput!
  deleteManyBuildingManager(where: BuildingManagerWhereInput): AffectedRowsOutput!
  deleteManyOffice(where: OfficeWhereInput): AffectedRowsOutput!
  deleteManyOfficeManager(where: OfficeManagerWhereInput): AffectedRowsOutput!
  deleteManyReservation(where: ReservationWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOffice(where: OfficeWhereUniqueInput!): Office
  deleteOfficeManager(where: OfficeManagerWhereUniqueInput!): OfficeManager
  deleteReservation(where: ReservationWhereUniqueInput!): Reservation
  deleteUser(where: UserWhereUniqueInput!): User
  updateBookableItem(data: BookableItemUpdateInput!, where: BookableItemWhereUniqueInput!): BookableItem
  updateBookableItemTypes(data: BookableItemTypesUpdateInput!, where: BookableItemTypesWhereUniqueInput!): BookableItemTypes
  updateBuilding(data: BuildingUpdateInput!, where: BuildingWhereUniqueInput!): Building
  updateBuildingManager(data: BuildingManagerUpdateInput!, where: BuildingManagerWhereUniqueInput!): BuildingManager
  updateManyBookableItem(data: BookableItemUpdateManyMutationInput!, where: BookableItemWhereInput): AffectedRowsOutput!
  updateManyBookableItemTypes(data: BookableItemTypesUpdateManyMutationInput!, where: BookableItemTypesWhereInput): AffectedRowsOutput!
  updateManyBuilding(data: BuildingUpdateManyMutationInput!, where: BuildingWhereInput): AffectedRowsOutput!
  updateManyBuildingManager(data: BuildingManagerUpdateManyMutationInput!, where: BuildingManagerWhereInput): AffectedRowsOutput!
  updateManyOffice(data: OfficeUpdateManyMutationInput!, where: OfficeWhereInput): AffectedRowsOutput!
  updateManyOfficeManager(data: OfficeManagerUpdateManyMutationInput!, where: OfficeManagerWhereInput): AffectedRowsOutput!
  updateManyReservation(data: ReservationUpdateManyMutationInput!, where: ReservationWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOffice(data: OfficeUpdateInput!, where: OfficeWhereUniqueInput!): Office
  updateOfficeManager(data: OfficeManagerUpdateInput!, where: OfficeManagerWhereUniqueInput!): OfficeManager
  updateReservation(data: ReservationUpdateInput!, where: ReservationWhereUniqueInput!): Reservation
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertBookableItem(create: BookableItemCreateInput!, update: BookableItemUpdateInput!, where: BookableItemWhereUniqueInput!): BookableItem!
  upsertBookableItemTypes(create: BookableItemTypesCreateInput!, update: BookableItemTypesUpdateInput!, where: BookableItemTypesWhereUniqueInput!): BookableItemTypes!
  upsertBuilding(create: BuildingCreateInput!, update: BuildingUpdateInput!, where: BuildingWhereUniqueInput!): Building!
  upsertBuildingManager(create: BuildingManagerCreateInput!, update: BuildingManagerUpdateInput!, where: BuildingManagerWhereUniqueInput!): BuildingManager!
  upsertOffice(create: OfficeCreateInput!, update: OfficeUpdateInput!, where: OfficeWhereUniqueInput!): Office!
  upsertOfficeManager(create: OfficeManagerCreateInput!, update: OfficeManagerUpdateInput!, where: OfficeManagerWhereUniqueInput!): OfficeManager!
  upsertReservation(create: ReservationCreateInput!, update: ReservationUpdateInput!, where: ReservationWhereUniqueInput!): Reservation!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedBoolNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBoolNullableFilter
  _min: NestedBoolNullableFilter
  equals: Boolean
  not: NestedBoolNullableWithAggregatesFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableBoolFieldUpdateOperationsInput {
  set: Boolean
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Office {
  bookableItems(cursor: BookableItemWhereUniqueInput, distinct: [BookableItemScalarFieldEnum!], orderBy: [BookableItemOrderByInput!], skip: Int, take: Int, where: BookableItemWhereInput): [BookableItem!]!
  building: Building!
  buildingId: Int!
  createdAt: DateTime
  id: Int!
  officeManagers(cursor: OfficeManagerWhereUniqueInput, distinct: [OfficeManagerScalarFieldEnum!], orderBy: [OfficeManagerOrderByInput!], skip: Int, take: Int, where: OfficeManagerWhereInput): [OfficeManager!]!
  updatedAt: DateTime
}

type OfficeAvgAggregate {
  buildingId: Float
  id: Float
}

type OfficeCountAggregate {
  _all: Int!
  buildingId: Int!
  createdAt: Int!
  id: Int!
  updatedAt: Int!
}

input OfficeCreateInput {
  bookableItems: BookableItemCreateNestedManyWithoutOfficeInput
  building: BuildingCreateNestedOneWithoutOfficesInput!
  createdAt: DateTime
  officeManagers: OfficeManagerCreateNestedManyWithoutOfficeInput
  updatedAt: DateTime
}

input OfficeCreateManyBuildingInput {
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input OfficeCreateManyBuildingInputEnvelope {
  data: [OfficeCreateManyBuildingInput!]!
  skipDuplicates: Boolean
}

input OfficeCreateManyInput {
  buildingId: Int!
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input OfficeCreateNestedManyWithoutBuildingInput {
  connect: [OfficeWhereUniqueInput!]
  connectOrCreate: [OfficeCreateOrConnectWithoutBuildingInput!]
  create: [OfficeCreateWithoutBuildingInput!]
  createMany: OfficeCreateManyBuildingInputEnvelope
}

input OfficeCreateNestedOneWithoutBookableItemsInput {
  connect: OfficeWhereUniqueInput
  connectOrCreate: OfficeCreateOrConnectWithoutBookableItemsInput
  create: OfficeCreateWithoutBookableItemsInput
}

input OfficeCreateNestedOneWithoutOfficeManagersInput {
  connect: OfficeWhereUniqueInput
  connectOrCreate: OfficeCreateOrConnectWithoutOfficeManagersInput
  create: OfficeCreateWithoutOfficeManagersInput
}

input OfficeCreateOrConnectWithoutBookableItemsInput {
  create: OfficeCreateWithoutBookableItemsInput!
  where: OfficeWhereUniqueInput!
}

input OfficeCreateOrConnectWithoutBuildingInput {
  create: OfficeCreateWithoutBuildingInput!
  where: OfficeWhereUniqueInput!
}

input OfficeCreateOrConnectWithoutOfficeManagersInput {
  create: OfficeCreateWithoutOfficeManagersInput!
  where: OfficeWhereUniqueInput!
}

input OfficeCreateWithoutBookableItemsInput {
  building: BuildingCreateNestedOneWithoutOfficesInput!
  createdAt: DateTime
  officeManagers: OfficeManagerCreateNestedManyWithoutOfficeInput
  updatedAt: DateTime
}

input OfficeCreateWithoutBuildingInput {
  bookableItems: BookableItemCreateNestedManyWithoutOfficeInput
  createdAt: DateTime
  officeManagers: OfficeManagerCreateNestedManyWithoutOfficeInput
  updatedAt: DateTime
}

input OfficeCreateWithoutOfficeManagersInput {
  bookableItems: BookableItemCreateNestedManyWithoutOfficeInput
  building: BuildingCreateNestedOneWithoutOfficesInput!
  createdAt: DateTime
  updatedAt: DateTime
}

type OfficeGroupBy {
  _avg: OfficeAvgAggregate
  _count: OfficeCountAggregate
  _max: OfficeMaxAggregate
  _min: OfficeMinAggregate
  _sum: OfficeSumAggregate
  buildingId: Int!
  createdAt: DateTime
  id: Int!
  updatedAt: DateTime
}

input OfficeListRelationFilter {
  every: OfficeWhereInput
  none: OfficeWhereInput
  some: OfficeWhereInput
}

type OfficeManager {
  createdAt: DateTime
  id: Int!
  name: String!
  office: Office!
  officeId: Int!
  updatedAt: DateTime
}

type OfficeManagerAvgAggregate {
  id: Float
  officeId: Float
}

type OfficeManagerCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  officeId: Int!
  updatedAt: Int!
}

input OfficeManagerCreateInput {
  createdAt: DateTime
  name: String!
  office: OfficeCreateNestedOneWithoutOfficeManagersInput!
  updatedAt: DateTime
}

input OfficeManagerCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  officeId: Int!
  updatedAt: DateTime
}

input OfficeManagerCreateManyOfficeInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input OfficeManagerCreateManyOfficeInputEnvelope {
  data: [OfficeManagerCreateManyOfficeInput!]!
  skipDuplicates: Boolean
}

input OfficeManagerCreateNestedManyWithoutOfficeInput {
  connect: [OfficeManagerWhereUniqueInput!]
  connectOrCreate: [OfficeManagerCreateOrConnectWithoutOfficeInput!]
  create: [OfficeManagerCreateWithoutOfficeInput!]
  createMany: OfficeManagerCreateManyOfficeInputEnvelope
}

input OfficeManagerCreateOrConnectWithoutOfficeInput {
  create: OfficeManagerCreateWithoutOfficeInput!
  where: OfficeManagerWhereUniqueInput!
}

input OfficeManagerCreateWithoutOfficeInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

type OfficeManagerGroupBy {
  _avg: OfficeManagerAvgAggregate
  _count: OfficeManagerCountAggregate
  _max: OfficeManagerMaxAggregate
  _min: OfficeManagerMinAggregate
  _sum: OfficeManagerSumAggregate
  createdAt: DateTime
  id: Int!
  name: String!
  officeId: Int!
  updatedAt: DateTime
}

input OfficeManagerListRelationFilter {
  every: OfficeManagerWhereInput
  none: OfficeManagerWhereInput
  some: OfficeManagerWhereInput
}

type OfficeManagerMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  officeId: Int
  updatedAt: DateTime
}

type OfficeManagerMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  officeId: Int
  updatedAt: DateTime
}

input OfficeManagerOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  officeId: SortOrder
  updatedAt: SortOrder
}

enum OfficeManagerScalarFieldEnum {
  createdAt
  id
  name
  officeId
  updatedAt
}

input OfficeManagerScalarWhereInput {
  AND: [OfficeManagerScalarWhereInput!]
  NOT: [OfficeManagerScalarWhereInput!]
  OR: [OfficeManagerScalarWhereInput!]
  createdAt: DateTimeNullableFilter
  id: IntFilter
  name: StringFilter
  officeId: IntFilter
  updatedAt: DateTimeNullableFilter
}

input OfficeManagerScalarWhereWithAggregatesInput {
  AND: [OfficeManagerScalarWhereWithAggregatesInput!]
  NOT: [OfficeManagerScalarWhereWithAggregatesInput!]
  OR: [OfficeManagerScalarWhereWithAggregatesInput!]
  createdAt: DateTimeNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  officeId: IntWithAggregatesFilter
  updatedAt: DateTimeNullableWithAggregatesFilter
}

type OfficeManagerSumAggregate {
  id: Int
  officeId: Int
}

input OfficeManagerUpdateInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  office: OfficeUpdateOneRequiredWithoutOfficeManagersInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input OfficeManagerUpdateManyMutationInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input OfficeManagerUpdateManyWithWhereWithoutOfficeInput {
  data: OfficeManagerUpdateManyMutationInput!
  where: OfficeManagerScalarWhereInput!
}

input OfficeManagerUpdateManyWithoutOfficeInput {
  connect: [OfficeManagerWhereUniqueInput!]
  connectOrCreate: [OfficeManagerCreateOrConnectWithoutOfficeInput!]
  create: [OfficeManagerCreateWithoutOfficeInput!]
  createMany: OfficeManagerCreateManyOfficeInputEnvelope
  delete: [OfficeManagerWhereUniqueInput!]
  deleteMany: [OfficeManagerScalarWhereInput!]
  disconnect: [OfficeManagerWhereUniqueInput!]
  set: [OfficeManagerWhereUniqueInput!]
  update: [OfficeManagerUpdateWithWhereUniqueWithoutOfficeInput!]
  updateMany: [OfficeManagerUpdateManyWithWhereWithoutOfficeInput!]
  upsert: [OfficeManagerUpsertWithWhereUniqueWithoutOfficeInput!]
}

input OfficeManagerUpdateWithWhereUniqueWithoutOfficeInput {
  data: OfficeManagerUpdateWithoutOfficeInput!
  where: OfficeManagerWhereUniqueInput!
}

input OfficeManagerUpdateWithoutOfficeInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input OfficeManagerUpsertWithWhereUniqueWithoutOfficeInput {
  create: OfficeManagerCreateWithoutOfficeInput!
  update: OfficeManagerUpdateWithoutOfficeInput!
  where: OfficeManagerWhereUniqueInput!
}

input OfficeManagerWhereInput {
  AND: [OfficeManagerWhereInput!]
  NOT: [OfficeManagerWhereInput!]
  OR: [OfficeManagerWhereInput!]
  createdAt: DateTimeNullableFilter
  id: IntFilter
  name: StringFilter
  office: OfficeRelationFilter
  officeId: IntFilter
  updatedAt: DateTimeNullableFilter
}

input OfficeManagerWhereUniqueInput {
  id: Int
}

type OfficeMaxAggregate {
  buildingId: Int
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

type OfficeMinAggregate {
  buildingId: Int
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input OfficeOrderByInput {
  buildingId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input OfficeRelationFilter {
  is: OfficeWhereInput
  isNot: OfficeWhereInput
}

enum OfficeScalarFieldEnum {
  buildingId
  createdAt
  id
  updatedAt
}

input OfficeScalarWhereInput {
  AND: [OfficeScalarWhereInput!]
  NOT: [OfficeScalarWhereInput!]
  OR: [OfficeScalarWhereInput!]
  buildingId: IntFilter
  createdAt: DateTimeNullableFilter
  id: IntFilter
  updatedAt: DateTimeNullableFilter
}

input OfficeScalarWhereWithAggregatesInput {
  AND: [OfficeScalarWhereWithAggregatesInput!]
  NOT: [OfficeScalarWhereWithAggregatesInput!]
  OR: [OfficeScalarWhereWithAggregatesInput!]
  buildingId: IntWithAggregatesFilter
  createdAt: DateTimeNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeNullableWithAggregatesFilter
}

type OfficeSumAggregate {
  buildingId: Int
  id: Int
}

input OfficeUpdateInput {
  bookableItems: BookableItemUpdateManyWithoutOfficeInput
  building: BuildingUpdateOneRequiredWithoutOfficesInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  officeManagers: OfficeManagerUpdateManyWithoutOfficeInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input OfficeUpdateManyMutationInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input OfficeUpdateManyWithWhereWithoutBuildingInput {
  data: OfficeUpdateManyMutationInput!
  where: OfficeScalarWhereInput!
}

input OfficeUpdateManyWithoutBuildingInput {
  connect: [OfficeWhereUniqueInput!]
  connectOrCreate: [OfficeCreateOrConnectWithoutBuildingInput!]
  create: [OfficeCreateWithoutBuildingInput!]
  createMany: OfficeCreateManyBuildingInputEnvelope
  delete: [OfficeWhereUniqueInput!]
  deleteMany: [OfficeScalarWhereInput!]
  disconnect: [OfficeWhereUniqueInput!]
  set: [OfficeWhereUniqueInput!]
  update: [OfficeUpdateWithWhereUniqueWithoutBuildingInput!]
  updateMany: [OfficeUpdateManyWithWhereWithoutBuildingInput!]
  upsert: [OfficeUpsertWithWhereUniqueWithoutBuildingInput!]
}

input OfficeUpdateOneRequiredWithoutBookableItemsInput {
  connect: OfficeWhereUniqueInput
  connectOrCreate: OfficeCreateOrConnectWithoutBookableItemsInput
  create: OfficeCreateWithoutBookableItemsInput
  update: OfficeUpdateWithoutBookableItemsInput
  upsert: OfficeUpsertWithoutBookableItemsInput
}

input OfficeUpdateOneRequiredWithoutOfficeManagersInput {
  connect: OfficeWhereUniqueInput
  connectOrCreate: OfficeCreateOrConnectWithoutOfficeManagersInput
  create: OfficeCreateWithoutOfficeManagersInput
  update: OfficeUpdateWithoutOfficeManagersInput
  upsert: OfficeUpsertWithoutOfficeManagersInput
}

input OfficeUpdateWithWhereUniqueWithoutBuildingInput {
  data: OfficeUpdateWithoutBuildingInput!
  where: OfficeWhereUniqueInput!
}

input OfficeUpdateWithoutBookableItemsInput {
  building: BuildingUpdateOneRequiredWithoutOfficesInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  officeManagers: OfficeManagerUpdateManyWithoutOfficeInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input OfficeUpdateWithoutBuildingInput {
  bookableItems: BookableItemUpdateManyWithoutOfficeInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  officeManagers: OfficeManagerUpdateManyWithoutOfficeInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input OfficeUpdateWithoutOfficeManagersInput {
  bookableItems: BookableItemUpdateManyWithoutOfficeInput
  building: BuildingUpdateOneRequiredWithoutOfficesInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input OfficeUpsertWithWhereUniqueWithoutBuildingInput {
  create: OfficeCreateWithoutBuildingInput!
  update: OfficeUpdateWithoutBuildingInput!
  where: OfficeWhereUniqueInput!
}

input OfficeUpsertWithoutBookableItemsInput {
  create: OfficeCreateWithoutBookableItemsInput!
  update: OfficeUpdateWithoutBookableItemsInput!
}

input OfficeUpsertWithoutOfficeManagersInput {
  create: OfficeCreateWithoutOfficeManagersInput!
  update: OfficeUpdateWithoutOfficeManagersInput!
}

input OfficeWhereInput {
  AND: [OfficeWhereInput!]
  NOT: [OfficeWhereInput!]
  OR: [OfficeWhereInput!]
  bookableItems: BookableItemListRelationFilter
  building: BuildingRelationFilter
  buildingId: IntFilter
  createdAt: DateTimeNullableFilter
  id: IntFilter
  officeManagers: OfficeManagerListRelationFilter
  updatedAt: DateTimeNullableFilter
}

input OfficeWhereUniqueInput {
  id: Int
}

type Query {
  aggregateBookableItem(cursor: BookableItemWhereUniqueInput, orderBy: [BookableItemOrderByInput!], skip: Int, take: Int, where: BookableItemWhereInput): AggregateBookableItem!
  aggregateBookableItemTypes(cursor: BookableItemTypesWhereUniqueInput, orderBy: [BookableItemTypesOrderByInput!], skip: Int, take: Int, where: BookableItemTypesWhereInput): AggregateBookableItemTypes!
  aggregateBuilding(cursor: BuildingWhereUniqueInput, orderBy: [BuildingOrderByInput!], skip: Int, take: Int, where: BuildingWhereInput): AggregateBuilding!
  aggregateBuildingManager(cursor: BuildingManagerWhereUniqueInput, orderBy: [BuildingManagerOrderByInput!], skip: Int, take: Int, where: BuildingManagerWhereInput): AggregateBuildingManager!
  aggregateOffice(cursor: OfficeWhereUniqueInput, orderBy: [OfficeOrderByInput!], skip: Int, take: Int, where: OfficeWhereInput): AggregateOffice!
  aggregateOfficeManager(cursor: OfficeManagerWhereUniqueInput, orderBy: [OfficeManagerOrderByInput!], skip: Int, take: Int, where: OfficeManagerWhereInput): AggregateOfficeManager!
  aggregateReservation(cursor: ReservationWhereUniqueInput, orderBy: [ReservationOrderByInput!], skip: Int, take: Int, where: ReservationWhereInput): AggregateReservation!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  bookableItem(where: BookableItemWhereUniqueInput!): BookableItem
  bookableItems(cursor: BookableItemWhereUniqueInput, distinct: [BookableItemScalarFieldEnum!], orderBy: [BookableItemOrderByInput!], skip: Int, take: Int, where: BookableItemWhereInput): [BookableItem!]!
  building(where: BuildingWhereUniqueInput!): Building
  buildingManager(where: BuildingManagerWhereUniqueInput!): BuildingManager
  buildingManagers(cursor: BuildingManagerWhereUniqueInput, distinct: [BuildingManagerScalarFieldEnum!], orderBy: [BuildingManagerOrderByInput!], skip: Int, take: Int, where: BuildingManagerWhereInput): [BuildingManager!]!
  buildings(cursor: BuildingWhereUniqueInput, distinct: [BuildingScalarFieldEnum!], orderBy: [BuildingOrderByInput!], skip: Int, take: Int, where: BuildingWhereInput): [Building!]!
  findFirstBookableItem(cursor: BookableItemWhereUniqueInput, distinct: [BookableItemScalarFieldEnum!], orderBy: [BookableItemOrderByInput!], skip: Int, take: Int, where: BookableItemWhereInput): BookableItem
  findFirstBookableItemTypes(cursor: BookableItemTypesWhereUniqueInput, distinct: [BookableItemTypesScalarFieldEnum!], orderBy: [BookableItemTypesOrderByInput!], skip: Int, take: Int, where: BookableItemTypesWhereInput): BookableItemTypes
  findFirstBuilding(cursor: BuildingWhereUniqueInput, distinct: [BuildingScalarFieldEnum!], orderBy: [BuildingOrderByInput!], skip: Int, take: Int, where: BuildingWhereInput): Building
  findFirstBuildingManager(cursor: BuildingManagerWhereUniqueInput, distinct: [BuildingManagerScalarFieldEnum!], orderBy: [BuildingManagerOrderByInput!], skip: Int, take: Int, where: BuildingManagerWhereInput): BuildingManager
  findFirstOffice(cursor: OfficeWhereUniqueInput, distinct: [OfficeScalarFieldEnum!], orderBy: [OfficeOrderByInput!], skip: Int, take: Int, where: OfficeWhereInput): Office
  findFirstOfficeManager(cursor: OfficeManagerWhereUniqueInput, distinct: [OfficeManagerScalarFieldEnum!], orderBy: [OfficeManagerOrderByInput!], skip: Int, take: Int, where: OfficeManagerWhereInput): OfficeManager
  findFirstReservation(cursor: ReservationWhereUniqueInput, distinct: [ReservationScalarFieldEnum!], orderBy: [ReservationOrderByInput!], skip: Int, take: Int, where: ReservationWhereInput): Reservation
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): User
  findManyBookableItemTypes(cursor: BookableItemTypesWhereUniqueInput, distinct: [BookableItemTypesScalarFieldEnum!], orderBy: [BookableItemTypesOrderByInput!], skip: Int, take: Int, where: BookableItemTypesWhereInput): [BookableItemTypes!]!
  findUniqueBookableItemTypes(where: BookableItemTypesWhereUniqueInput!): BookableItemTypes
  groupByBookableItem(by: [BookableItemScalarFieldEnum!]!, having: BookableItemScalarWhereWithAggregatesInput, orderBy: [BookableItemOrderByInput!], skip: Int, take: Int, where: BookableItemWhereInput): [BookableItemGroupBy!]!
  groupByBookableItemTypes(by: [BookableItemTypesScalarFieldEnum!]!, having: BookableItemTypesScalarWhereWithAggregatesInput, orderBy: [BookableItemTypesOrderByInput!], skip: Int, take: Int, where: BookableItemTypesWhereInput): [BookableItemTypesGroupBy!]!
  groupByBuilding(by: [BuildingScalarFieldEnum!]!, having: BuildingScalarWhereWithAggregatesInput, orderBy: [BuildingOrderByInput!], skip: Int, take: Int, where: BuildingWhereInput): [BuildingGroupBy!]!
  groupByBuildingManager(by: [BuildingManagerScalarFieldEnum!]!, having: BuildingManagerScalarWhereWithAggregatesInput, orderBy: [BuildingManagerOrderByInput!], skip: Int, take: Int, where: BuildingManagerWhereInput): [BuildingManagerGroupBy!]!
  groupByOffice(by: [OfficeScalarFieldEnum!]!, having: OfficeScalarWhereWithAggregatesInput, orderBy: [OfficeOrderByInput!], skip: Int, take: Int, where: OfficeWhereInput): [OfficeGroupBy!]!
  groupByOfficeManager(by: [OfficeManagerScalarFieldEnum!]!, having: OfficeManagerScalarWhereWithAggregatesInput, orderBy: [OfficeManagerOrderByInput!], skip: Int, take: Int, where: OfficeManagerWhereInput): [OfficeManagerGroupBy!]!
  groupByReservation(by: [ReservationScalarFieldEnum!]!, having: ReservationScalarWhereWithAggregatesInput, orderBy: [ReservationOrderByInput!], skip: Int, take: Int, where: ReservationWhereInput): [ReservationGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  office(where: OfficeWhereUniqueInput!): Office
  officeManager(where: OfficeManagerWhereUniqueInput!): OfficeManager
  officeManagers(cursor: OfficeManagerWhereUniqueInput, distinct: [OfficeManagerScalarFieldEnum!], orderBy: [OfficeManagerOrderByInput!], skip: Int, take: Int, where: OfficeManagerWhereInput): [OfficeManager!]!
  offices(cursor: OfficeWhereUniqueInput, distinct: [OfficeScalarFieldEnum!], orderBy: [OfficeOrderByInput!], skip: Int, take: Int, where: OfficeWhereInput): [Office!]!
  reservation(where: ReservationWhereUniqueInput!): Reservation
  reservations(cursor: ReservationWhereUniqueInput, distinct: [ReservationScalarFieldEnum!], orderBy: [ReservationOrderByInput!], skip: Int, take: Int, where: ReservationWhereInput): [Reservation!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Reservation {
  bookedItem: BookableItem!
  bookedItemId: Int!
  cancelled: Boolean!
  createdAt: DateTime
  dateBookedFrom: DateTime!
  dateBookedTo: DateTime!
  id: Int!
  updatedAt: DateTime
  user: User!
  userId: Int!
}

type ReservationAvgAggregate {
  bookedItemId: Float
  id: Float
  userId: Float
}

type ReservationCountAggregate {
  _all: Int!
  bookedItemId: Int!
  cancelled: Int!
  createdAt: Int!
  dateBookedFrom: Int!
  dateBookedTo: Int!
  id: Int!
  updatedAt: Int!
  userId: Int!
}

input ReservationCreateInput {
  bookedItem: BookableItemCreateNestedOneWithoutReservationsInput!
  cancelled: Boolean!
  createdAt: DateTime
  dateBookedFrom: DateTime!
  dateBookedTo: DateTime!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutReservationsInput!
}

input ReservationCreateManyBookedItemInput {
  cancelled: Boolean!
  createdAt: DateTime
  dateBookedFrom: DateTime!
  dateBookedTo: DateTime!
  id: Int
  updatedAt: DateTime
  userId: Int!
}

input ReservationCreateManyBookedItemInputEnvelope {
  data: [ReservationCreateManyBookedItemInput!]!
  skipDuplicates: Boolean
}

input ReservationCreateManyInput {
  bookedItemId: Int!
  cancelled: Boolean!
  createdAt: DateTime
  dateBookedFrom: DateTime!
  dateBookedTo: DateTime!
  id: Int
  updatedAt: DateTime
  userId: Int!
}

input ReservationCreateManyUserInput {
  bookedItemId: Int!
  cancelled: Boolean!
  createdAt: DateTime
  dateBookedFrom: DateTime!
  dateBookedTo: DateTime!
  id: Int
  updatedAt: DateTime
}

input ReservationCreateManyUserInputEnvelope {
  data: [ReservationCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ReservationCreateNestedManyWithoutBookedItemInput {
  connect: [ReservationWhereUniqueInput!]
  connectOrCreate: [ReservationCreateOrConnectWithoutBookedItemInput!]
  create: [ReservationCreateWithoutBookedItemInput!]
  createMany: ReservationCreateManyBookedItemInputEnvelope
}

input ReservationCreateNestedManyWithoutUserInput {
  connect: [ReservationWhereUniqueInput!]
  connectOrCreate: [ReservationCreateOrConnectWithoutUserInput!]
  create: [ReservationCreateWithoutUserInput!]
  createMany: ReservationCreateManyUserInputEnvelope
}

input ReservationCreateOrConnectWithoutBookedItemInput {
  create: ReservationCreateWithoutBookedItemInput!
  where: ReservationWhereUniqueInput!
}

input ReservationCreateOrConnectWithoutUserInput {
  create: ReservationCreateWithoutUserInput!
  where: ReservationWhereUniqueInput!
}

input ReservationCreateWithoutBookedItemInput {
  cancelled: Boolean!
  createdAt: DateTime
  dateBookedFrom: DateTime!
  dateBookedTo: DateTime!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutReservationsInput!
}

input ReservationCreateWithoutUserInput {
  bookedItem: BookableItemCreateNestedOneWithoutReservationsInput!
  cancelled: Boolean!
  createdAt: DateTime
  dateBookedFrom: DateTime!
  dateBookedTo: DateTime!
  updatedAt: DateTime
}

type ReservationGroupBy {
  _avg: ReservationAvgAggregate
  _count: ReservationCountAggregate
  _max: ReservationMaxAggregate
  _min: ReservationMinAggregate
  _sum: ReservationSumAggregate
  bookedItemId: Int!
  cancelled: Boolean!
  createdAt: DateTime
  dateBookedFrom: DateTime!
  dateBookedTo: DateTime!
  id: Int!
  updatedAt: DateTime
  userId: Int!
}

input ReservationListRelationFilter {
  every: ReservationWhereInput
  none: ReservationWhereInput
  some: ReservationWhereInput
}

type ReservationMaxAggregate {
  bookedItemId: Int
  cancelled: Boolean
  createdAt: DateTime
  dateBookedFrom: DateTime
  dateBookedTo: DateTime
  id: Int
  updatedAt: DateTime
  userId: Int
}

type ReservationMinAggregate {
  bookedItemId: Int
  cancelled: Boolean
  createdAt: DateTime
  dateBookedFrom: DateTime
  dateBookedTo: DateTime
  id: Int
  updatedAt: DateTime
  userId: Int
}

input ReservationOrderByInput {
  bookedItemId: SortOrder
  cancelled: SortOrder
  createdAt: SortOrder
  dateBookedFrom: SortOrder
  dateBookedTo: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

enum ReservationScalarFieldEnum {
  bookedItemId
  cancelled
  createdAt
  dateBookedFrom
  dateBookedTo
  id
  updatedAt
  userId
}

input ReservationScalarWhereInput {
  AND: [ReservationScalarWhereInput!]
  NOT: [ReservationScalarWhereInput!]
  OR: [ReservationScalarWhereInput!]
  bookedItemId: IntFilter
  cancelled: BoolFilter
  createdAt: DateTimeNullableFilter
  dateBookedFrom: DateTimeFilter
  dateBookedTo: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeNullableFilter
  userId: IntFilter
}

input ReservationScalarWhereWithAggregatesInput {
  AND: [ReservationScalarWhereWithAggregatesInput!]
  NOT: [ReservationScalarWhereWithAggregatesInput!]
  OR: [ReservationScalarWhereWithAggregatesInput!]
  bookedItemId: IntWithAggregatesFilter
  cancelled: BoolWithAggregatesFilter
  createdAt: DateTimeNullableWithAggregatesFilter
  dateBookedFrom: DateTimeWithAggregatesFilter
  dateBookedTo: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeNullableWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type ReservationSumAggregate {
  bookedItemId: Int
  id: Int
  userId: Int
}

input ReservationUpdateInput {
  bookedItem: BookableItemUpdateOneRequiredWithoutReservationsInput
  cancelled: BoolFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  dateBookedFrom: DateTimeFieldUpdateOperationsInput
  dateBookedTo: DateTimeFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutReservationsInput
}

input ReservationUpdateManyMutationInput {
  cancelled: BoolFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  dateBookedFrom: DateTimeFieldUpdateOperationsInput
  dateBookedTo: DateTimeFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input ReservationUpdateManyWithWhereWithoutBookedItemInput {
  data: ReservationUpdateManyMutationInput!
  where: ReservationScalarWhereInput!
}

input ReservationUpdateManyWithWhereWithoutUserInput {
  data: ReservationUpdateManyMutationInput!
  where: ReservationScalarWhereInput!
}

input ReservationUpdateManyWithoutBookedItemInput {
  connect: [ReservationWhereUniqueInput!]
  connectOrCreate: [ReservationCreateOrConnectWithoutBookedItemInput!]
  create: [ReservationCreateWithoutBookedItemInput!]
  createMany: ReservationCreateManyBookedItemInputEnvelope
  delete: [ReservationWhereUniqueInput!]
  deleteMany: [ReservationScalarWhereInput!]
  disconnect: [ReservationWhereUniqueInput!]
  set: [ReservationWhereUniqueInput!]
  update: [ReservationUpdateWithWhereUniqueWithoutBookedItemInput!]
  updateMany: [ReservationUpdateManyWithWhereWithoutBookedItemInput!]
  upsert: [ReservationUpsertWithWhereUniqueWithoutBookedItemInput!]
}

input ReservationUpdateManyWithoutUserInput {
  connect: [ReservationWhereUniqueInput!]
  connectOrCreate: [ReservationCreateOrConnectWithoutUserInput!]
  create: [ReservationCreateWithoutUserInput!]
  createMany: ReservationCreateManyUserInputEnvelope
  delete: [ReservationWhereUniqueInput!]
  deleteMany: [ReservationScalarWhereInput!]
  disconnect: [ReservationWhereUniqueInput!]
  set: [ReservationWhereUniqueInput!]
  update: [ReservationUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ReservationUpdateManyWithWhereWithoutUserInput!]
  upsert: [ReservationUpsertWithWhereUniqueWithoutUserInput!]
}

input ReservationUpdateWithWhereUniqueWithoutBookedItemInput {
  data: ReservationUpdateWithoutBookedItemInput!
  where: ReservationWhereUniqueInput!
}

input ReservationUpdateWithWhereUniqueWithoutUserInput {
  data: ReservationUpdateWithoutUserInput!
  where: ReservationWhereUniqueInput!
}

input ReservationUpdateWithoutBookedItemInput {
  cancelled: BoolFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  dateBookedFrom: DateTimeFieldUpdateOperationsInput
  dateBookedTo: DateTimeFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutReservationsInput
}

input ReservationUpdateWithoutUserInput {
  bookedItem: BookableItemUpdateOneRequiredWithoutReservationsInput
  cancelled: BoolFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  dateBookedFrom: DateTimeFieldUpdateOperationsInput
  dateBookedTo: DateTimeFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input ReservationUpsertWithWhereUniqueWithoutBookedItemInput {
  create: ReservationCreateWithoutBookedItemInput!
  update: ReservationUpdateWithoutBookedItemInput!
  where: ReservationWhereUniqueInput!
}

input ReservationUpsertWithWhereUniqueWithoutUserInput {
  create: ReservationCreateWithoutUserInput!
  update: ReservationUpdateWithoutUserInput!
  where: ReservationWhereUniqueInput!
}

input ReservationWhereInput {
  AND: [ReservationWhereInput!]
  NOT: [ReservationWhereInput!]
  OR: [ReservationWhereInput!]
  bookedItem: BookableItemRelationFilter
  bookedItemId: IntFilter
  cancelled: BoolFilter
  createdAt: DateTimeNullableFilter
  dateBookedFrom: DateTimeFilter
  dateBookedTo: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeNullableFilter
  user: UserRelationFilter
  userId: IntFilter
}

input ReservationWhereUniqueInput {
  id: Int
}

enum Role {
  ADMIN
  BUILDING_MANAGER
  OFFICE_MANAGER
  USER
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  createdAt: DateTime
  email: String!
  firstName: String
  id: Int!
  lastName: String
  password: String!
  reservations(cursor: ReservationWhereUniqueInput, distinct: [ReservationScalarFieldEnum!], orderBy: [ReservationOrderByInput!], skip: Int, take: Int, where: ReservationWhereInput): [Reservation!]!
  role: Role!
  updatedAt: DateTime
}

type UserAvgAggregate {
  id: Float
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  password: Int!
  role: Int!
  updatedAt: Int!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  firstName: String
  lastName: String
  password: String!
  reservations: ReservationCreateNestedManyWithoutUserInput
  role: Role
  updatedAt: DateTime
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String!
  firstName: String
  id: Int
  lastName: String
  password: String!
  role: Role
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutReservationsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutReservationsInput
  create: UserCreateWithoutReservationsInput
}

input UserCreateOrConnectWithoutReservationsInput {
  create: UserCreateWithoutReservationsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutReservationsInput {
  createdAt: DateTime
  email: String!
  firstName: String
  lastName: String
  password: String!
  role: Role
  updatedAt: DateTime
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  createdAt: DateTime
  email: String!
  firstName: String
  id: Int!
  lastName: String
  password: String!
  role: Role!
  updatedAt: DateTime
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  firstName: String
  id: Int
  lastName: String
  password: String
  role: Role
  updatedAt: DateTime
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  firstName: String
  id: Int
  lastName: String
  password: String
  role: Role
  updatedAt: DateTime
}

input UserOrderByInput {
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  firstName
  id
  lastName
  password
  role
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  lastName: StringNullableWithAggregatesFilter
  password: StringWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
  updatedAt: DateTimeNullableWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserUpdateInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  reservations: ReservationUpdateManyWithoutUserInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutReservationsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutReservationsInput
  create: UserCreateWithoutReservationsInput
  update: UserUpdateWithoutReservationsInput
  upsert: UserUpsertWithoutReservationsInput
}

input UserUpdateWithoutReservationsInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutReservationsInput {
  create: UserCreateWithoutReservationsInput!
  update: UserUpdateWithoutReservationsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeNullableFilter
  email: StringFilter
  firstName: StringNullableFilter
  id: IntFilter
  lastName: StringNullableFilter
  password: StringFilter
  reservations: ReservationListRelationFilter
  role: EnumRoleFilter
  updatedAt: DateTimeNullableFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
